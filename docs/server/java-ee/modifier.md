# 修饰符

## 访问修饰符
- 权限如下

| 访问修饰符      | 同一个类 | 同包 | 不同包，子类 | 不同包，非子类 |
|:----------------|:--------:|:----:|:------------:|:--------------:|
| private         |    √     |      |              |                |
| default（默认） |    √     |  √   |              |                |
| protected       |    √     |  √   |      √       |                |
| public          |    √     |  √   |      √       |       √        |


### default
  - 默认访问修饰符（不使用任何修饰符）
  - 使用对象：类、接口、变量、方法

### public
  - 公有访问修饰符
  - 使用对象：类、接口、变量、方法
  
### protected
  - 受保护的访问修饰符
  - 使用对象：变量、方法。**不能修饰类（外部类）**

### private
  - 私有访问修饰符
  - 使用对象：变量、方法。**不能修饰类（外部类）**


## 非访问修饰符
### static

#### 可修饰范围
- 成员变量
  1. 修饰：`类变量`或`静态变量`；
  2. 未修饰：`实例变量`或`非静态变量`；

- 成员方法
  1. 修饰：`类方法`或`静态方法`；
  2. 未修饰：`实例方法`或`非静态方法`；

- 代码块
  1. 修饰：`静态代码块`或`类初始化代码块`；
  2. 未修饰：`非静态代码块`、`实例化代码块`、`构造块`；

- 成员内部类
  1. 修饰：`静态成员内部类`或`静态内部类`；
  2. 未修饰：`非静态成员内部类`或`成员内部类`；

- 区别：用了`static`修饰的表示属于**类**，而不属于**某个对象**

#### 静态方法的区别
1. 静态方法的调用可以直接使用 `ClassName.methodName()` 调用。一般用于工具类中
2. 静态方法中不允许出现 `this`，`super` 等关键字
3. 静态方法不能被重写
4. `abstract methods` 不能是静态的。
5. 注意
    - 实例方法可以直接访问 `实例变量`、`实例方法`、`静态变量`、`静态方法`
    - 静态方法不可以直接访问 `实例变量`、`实例方法`，必须使用对象实例访问  
      **原因**：非静态的成员变量等需要先有 `实例对象`，才会开辟对应的 `堆` 内存空间，而静态方法调用时，有可能还没有对象，那么就无法访问对应的内存中的数据。为了避免访问不存在的内存空间，就需要阻止你在静态方法中直接使用它们。

#### 静态变量的特点
1. 静态变量也有默认值
2. 静态变量不需要在构造器中进行初始化
3. 当静态变量与局部变量同名时，使用静态变量时在前面使用 `类名.` 进行区分
4. 静态变量的 `get/set` 也是静态的

**静态方法跟静态变量也可以使用 对象实例 访问，但是不推荐，因为会使得我们无法分辨这个域是属于实例的还是类的。**

### final

1. 修饰变量：变量一旦赋值后，不能被重新赋值。
2. 修饰成员变量：赋值后不能重新赋值，而且必须显式的指定初始值（二选一）
    - 定义时直接赋值
    - 构造函数中赋值
3. 修饰成员方法：可以被子类继承，但是不能被子类重写。
4. 修饰类：不能被继承，没有类能够继承 final 类的任何特性。
5. 修饰参数：final修饰传入方法的参数时，该参数只读，不可以修改。


### abstract

1. 抽象类不能被实例化
2. 抽象类中不一定包含抽象方法，但是有抽象方法的类必定是抽象类。
3. 抽象类中的抽象方法只是声明，不包含方法体，就是不给出方法的具体实现也就是方法的具体功能。
4. 构造方法，类方法（用 static 修饰的方法）不能声明为抽象方法。
5. 抽象类的子类必须给出抽象类中的抽象方法的具体实现，除非该子类也是抽象类。

### synchronized
### transient
### volatile