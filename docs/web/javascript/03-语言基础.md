# 语言基础

[[toc]]

- 标识符：变量、属性、函数、函数参数名称。
- 关键字：case、break、if、else、typeof。
- 保留字：enum、package、public。

## var 关键字

### 1. 声明作用域

```js
function test() {
  var message = "hi"; // 局部变量，函数调用后就会被销毁
}
test();
console.log(message); // ReferenceError: message is not defined
```

```js
function test() {
  message = "hi"; // 全局变量
}
test();
console.log(message); // hi
```

### 2. 声明提升

```js
console.log(age); // undefined
var age = 26;
```

不会报错，因为使用`var`声明的变量会自动提升到函数作用域的顶部，等价于如下：

```js
var age;
console.log(age); // undefined
age = 26;
```

## let 声明

### 1. 块作用域

- `let`声明的作用域仅限于该代码块内部，是函数作用域的子集。`ES5`只有全局作用域和函数作用域。

```js
if (true) {
  var name = "Jack";
  let age = 26;
}
console.log(name); // Jack
console.log(age); // ReferenceError: age is not defined
```

### 2. 同一个块级作用域中不允许重复声明

- `let`和`var`混用也不允许重复声明，因为这两个关键字声明的是同类型的变量，只是指出变量在相关的作用域如何存在。

```js
var name;
let age;

let name; // SyntaxError: Identifier 'name' has already been declared
let age; // SyntaxError: Identifier 'age' has already been declared
```

- 嵌套使用时不会报错，因为变量声明的标识符和所在的块作用域不同。

```js
let age = 26;
if (true) {
  let age = 30;
  console.log(age); // 30
}
console.log(age); // 30
```

### 3. 暂时性死区

#### 3.1 变量不会被提升

- 在代码块内，通过`let`声明的变量在声明执行之前，该变量都是不可用的，这在语法上称为“暂时性死区”，简称 TDZ（temporal dead zone）。

```js
if (true) {
  // TDZ开始
  console.log(bar); // undefined
  console.log(foo); // ReferenceError: Cannot access 'foo' before initialization
  var bar = 1;
  let foo = 2; // TDZ结束
}
```

#### 3.2 暂时性死区 typeof

- “暂时性死区”也意味着`typeof`不再是一个百分之百安全的操作，如果使用`typeof`检测暂时性死区的变量，会抛出`ReferenceError`。

```js
console.log(typeof a); // undefined
console.log(typeof b); // ReferenceError: Cannot access 'b' before initialization

let b;
```

- 变量`b`在声明执行之前都属于`b`的死区，只要用到`b`变量就会抛出`ReferenceError`。而`a`是一个不存在的变量，反而返回`undefined`。

### 4. 全局声明

- 在全局作用域中`var`声明的变量会变成`window`对象的属性，而`let`不会，不过`let`声明仍然是在全局作用域中发生的，相应的变量会在页面的生命周期内存续。因此，重复声明时还是会报错。

```js
var name = "Jack";
console.log(window.name); // Jack

let age = 26;
console.log(window.age); // undefined

let age = 30; // SyntaxError: Identifier 'age' has already been declared
```

### 5. for 循环中的 let 声明

```js
for (var i = 0; i < 5; ++i) {
  // 循环逻辑
}
console.log(i); // 5

for (let j = 0; j < 5; ++j) {
  // 循环逻辑
}
console.log(j); // ReferenceError: j is not defined

for (var i = 0; i < 5; ++i) {
  setTimeout(() => {
    // 每个循环都引用全局的 i 变量
    console.log(i); // 输出：5、5、5、5、5
  }, 1000);
}

for (let i = 0; i < 5; ++i) {
  setTimeout(() => {
    // 每个循环引用不同的 i 变量
    console.log(i); // 输出：0、1、2、3、4
  }, 1000);
}
```

- 使用`var`声明的`i`变量是一个全局变量，即每次循环时修改访问的都是同一个全局变量。而`let`迭代变量的作用域仅限于`for`循环内部，相当于每一次循环的`i`都是一个新的变量，
